# Sync project board fields from transient "signal labels".
#
# MCP tools can only set labels — they cannot manage GitHub Projects V2 fields.
# This workflow bridges that gap:
#   1. Agent adds a signal label like `set:priority:p1` via MCP issue_write.
#   2. This workflow fires, maps the label to the correct project field + option.
#   3. Sets the field value via GraphQL updateProjectV2ItemFieldValue.
#   4. Removes the signal label so only real labels remain.
#
# Signal label format: set:<field>:<value>
#   - set:priority:p0 | p1 | p2 | p3
#   - set:size:xs | s | m | l
#   - set:workmode:cloud-agent | local-ide
#   - set:status:backlog | ready | in-progress | in-review | done
#
# Also supports workflow_dispatch to bootstrap signal labels in the repo.

name: Sync Project Fields

on:
  issues:
    types: [labeled]
  workflow_dispatch:
    inputs:
      action:
        description: "Action to perform"
        required: true
        type: choice
        options:
          - create-signal-labels

env:
  PROJECT_NUMBER: 3

jobs:
  # ── Bootstrap: create or delete all signal labels ──────────────────
  manage-signal-labels:
    if: github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest
    permissions:
      issues: write
    steps:
      - name: Manage signal labels
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const action = '${{ inputs.action }}';

            const SIGNAL_LABELS = [
              { name: 'set:priority:p0', color: 'B60205', description: 'Signal: set Priority → P0' },
              { name: 'set:priority:p1', color: 'D93F0B', description: 'Signal: set Priority → P1' },
              { name: 'set:priority:p2', color: 'FBCA04', description: 'Signal: set Priority → P2' },
              { name: 'set:priority:p3', color: 'C2E0C6', description: 'Signal: set Priority → P3' },
              { name: 'set:size:xs',     color: 'BFD4F2', description: 'Signal: set Size → XS' },
              { name: 'set:size:s',      color: 'BFD4F2', description: 'Signal: set Size → S' },
              { name: 'set:size:m',      color: 'BFD4F2', description: 'Signal: set Size → M' },
              { name: 'set:size:l',      color: 'BFD4F2', description: 'Signal: set Size → L' },
              { name: 'set:workmode:cloud-agent', color: 'D4C5F9', description: 'Signal: set Work mode → Cloud Agent' },
              { name: 'set:workmode:local-ide',   color: 'D4C5F9', description: 'Signal: set Work mode → Local IDE' },
              { name: 'set:status:backlog',     color: 'E4E669', description: 'Signal: set Status → Backlog' },
              { name: 'set:status:ready',       color: 'E4E669', description: 'Signal: set Status → Ready' },
              { name: 'set:status:in-progress', color: 'E4E669', description: 'Signal: set Status → In Progress' },
              { name: 'set:status:in-review',   color: 'E4E669', description: 'Signal: set Status → In Review' },
              { name: 'set:status:done',        color: 'E4E669', description: 'Signal: set Status → Done' },
            ];

            if (action === 'create-signal-labels') {
              for (const label of SIGNAL_LABELS) {
                try {
                  await github.rest.issues.createLabel({ owner, repo, ...label });
                  core.info(`Created label: ${label.name}`);
                } catch (e) {
                  if (e.status === 422) {
                    core.info(`Label already exists: ${label.name}`);
                  } else {
                    core.warning(`Failed to create ${label.name}: ${e.message}`);
                  }
                }
              }
              core.info('All signal labels created.');
            }

  # ── Main: sync a signal label to a project field ───────────────────
  sync-field:
    if: >-
      github.event_name == 'issues'
      && startsWith(github.event.label.name, 'set:')
    runs-on: ubuntu-latest
    permissions:
      issues: write
    steps:
      - name: Update project field from signal label
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PROJECT_BOARD_TOKEN }}
          script: |
            const label = context.payload.label.name;
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const issueNumber = context.payload.issue.number;
            const projectNumber = Number(process.env.PROJECT_NUMBER);

            const removeSignalLabel = async () => {
              try {
                await github.rest.issues.removeLabel({
                  owner,
                  repo,
                  issue_number: issueNumber,
                  name: label,
                });
                core.info(`Removed signal label "${label}"`);
              } catch (e) {
                core.warning(`Failed to remove signal label "${label}": ${e.message}`);
              }
            };

            // ── Parse signal label ──────────────────────────────────
            const parts = label.split(':');
            if (parts.length !== 3) {
              core.warning(`Invalid signal label format: ${label} (expected set:<field>:<value>)`);
              return;
            }
            const [, fieldKey, optionKey] = parts;

            // ── Field → project field name + option matchers ────────
            // Option matchers are regex patterns matched against the project
            // board's actual option names. This makes the workflow resilient
            // to minor naming differences on the board.
            const FIELD_MAP = {
              priority: {
                fieldName: 'Priority',
                options: {
                  'p0': /p0/i,
                  'p1': /p1/i,
                  'p2': /p2/i,
                  'p3': /p3/i,
                },
              },
              size: {
                fieldName: 'Size',
                options: {
                  'xs': /\bxs\b/i,
                  's':  /\bs\b/i,
                  'm':  /\bm\b/i,
                  'l':  /\bl\b/i,
                },
              },
              workmode: {
                fieldName: 'Work mode',
                options: {
                  'cloud-agent': /cloud/i,
                  'local-ide':   /local/i,
                },
              },
              status: {
                fieldName: 'Status',
                options: {
                  'backlog':     /backlog/i,
                  'ready':       /\bready\b/i,
                  'in-progress': /in.?progress/i,
                  'in-review':   /in.?review/i,
                  'done':        /\bdone\b/i,
                },
              },
            };

            const fieldConfig = FIELD_MAP[fieldKey];
            if (!fieldConfig) {
              core.warning(`Unknown field key "${fieldKey}" in signal label "${label}". Valid keys: ${Object.keys(FIELD_MAP).join(', ')}`);
              return;
            }

            const optionMatcher = fieldConfig.options[optionKey];
            if (!optionMatcher) {
              core.warning(`Unknown option "${optionKey}" for field "${fieldKey}". Valid options: ${Object.keys(fieldConfig.options).join(', ')}`);
              return;
            }

            // `set:workmode:cloud-agent` is a compatibility signal.
            // Convert it to the real workflow trigger label and stop here.
            if (fieldKey === 'workmode' && optionKey === 'cloud-agent') {
              const labels = (context.payload.issue.labels || [])
                .map((entry) => typeof entry === 'string' ? entry : entry.name)
                .filter(Boolean);

              if (!labels.includes('cloud-agent')) {
                await github.rest.issues.addLabels({
                  owner,
                  repo,
                  issue_number: issueNumber,
                  labels: ['cloud-agent'],
                });
                core.info(`Added real label "cloud-agent" to issue #${issueNumber}`);
              } else {
                core.info(`Issue #${issueNumber} already has label "cloud-agent"`);
              }

              await removeSignalLabel();
              return;
            }

            // ── Find issue's project board item ─────────────────────
            const itemQuery = `
              query($owner: String!, $repo: String!, $issueNumber: Int!) {
                repository(owner: $owner, name: $repo) {
                  issue(number: $issueNumber) {
                    id
                    projectItems(first: 10) {
                      nodes {
                        id
                        project { id number }
                      }
                    }
                  }
                }
              }`;

            const itemResult = await github.graphql(itemQuery, { owner, repo, issueNumber });
            const issueNodeId = itemResult.repository.issue.id;
            let items = itemResult.repository.issue.projectItems.nodes;
            let boardItem = items.find(i => i.project.number === projectNumber);

            // If issue is not on the board, add it
            if (!boardItem) {
              const projectQuery = `
                query($owner: String!, $projectNumber: Int!) {
                  user(login: $owner) {
                    projectV2(number: $projectNumber) { id }
                  }
                }`;
              const projectResult = await github.graphql(projectQuery, { owner, projectNumber });
              const projectId = projectResult.user.projectV2.id;

              const addMutation = `
                mutation($projectId: ID!, $contentId: ID!) {
                  addProjectV2ItemById(input: { projectId: $projectId, contentId: $contentId }) {
                    item { id project { id number } }
                  }
                }`;
              const addResult = await github.graphql(addMutation, { projectId, contentId: issueNodeId });
              boardItem = addResult.addProjectV2ItemById.item;
              core.info(`Added issue #${issueNumber} to project board`);
            }

            const projectId = boardItem.project.id;
            const itemId = boardItem.id;

            // ── Get field definitions ───────────────────────────────
            const fieldQuery = `
              query($projectId: ID!) {
                node(id: $projectId) {
                  ... on ProjectV2 {
                    fields(first: 30) {
                      nodes {
                        ... on ProjectV2SingleSelectField {
                          id
                          name
                          options { id name }
                        }
                      }
                    }
                  }
                }
              }`;

            const fieldResult = await github.graphql(fieldQuery, { projectId });
            const fields = fieldResult.node.fields.nodes.filter(f => f.name);

            // ── Find target field + option ───────────────────────────
            const targetField = fields.find(f => f.name === fieldConfig.fieldName);
            if (!targetField) {
              core.warning(`Field "${fieldConfig.fieldName}" not found. Available: ${fields.map(f => f.name).join(', ')}`);
              await removeSignalLabel();
              return;
            }

            const targetOption = targetField.options.find(o => optionMatcher.test(o.name));
            if (!targetOption) {
              core.warning(`No matching option for "${optionKey}" in "${fieldConfig.fieldName}". Available: ${targetField.options.map(o => o.name).join(', ')}`);
              await removeSignalLabel();
              return;
            }

            // ── Set the field value ─────────────────────────────────
            const updateMutation = `
              mutation($projectId: ID!, $itemId: ID!, $fieldId: ID!, $optionId: String!) {
                updateProjectV2ItemFieldValue(
                  input: {
                    projectId: $projectId
                    itemId: $itemId
                    fieldId: $fieldId
                    value: { singleSelectOptionId: $optionId }
                  }
                ) { projectV2Item { id } }
              }`;

            await github.graphql(updateMutation, {
              projectId,
              itemId,
              fieldId: targetField.id,
              optionId: targetOption.id,
            });

            core.info(`✅ Set ${fieldConfig.fieldName} → ${targetOption.name} for issue #${issueNumber}`);

            // ── Remove the signal label ─────────────────────────────
            await removeSignalLabel();
