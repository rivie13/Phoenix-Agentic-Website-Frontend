name: Daily Blog â€” Engine Update

on:
  schedule:
    - cron: "0 6 * * *" # 6 AM UTC daily
  workflow_dispatch: # manual trigger for testing

# â”€â”€ Permissions â”€â”€
permissions:
  contents: write
  pull-requests: write
  models: read

# â”€â”€ Concurrency â€” prevent parallel runs â”€â”€
concurrency:
  group: daily-blog
  cancel-in-progress: true

jobs:
  generate:
    # Master kill-switch: set BLOG_ENABLED to 'false' in repo variables to stop
    if: vars.BLOG_ENABLED != 'false'
    runs-on: ubuntu-latest

    steps:
      # â”€â”€ 1. Checkout â”€â”€
      - name: Checkout website frontend
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GH_PAT || secrets.GITHUB_TOKEN }}

      # â”€â”€ 2. Setup Node â”€â”€
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20

      # â”€â”€ 3. Compute date window â”€â”€
      - name: Set date variables
        id: dates
        run: |
          echo "today=$(date -u +%Y-%m-%d)" >> "$GITHUB_OUTPUT"
          echo "since=$(date -u -d '24 hours ago' --iso-8601=seconds)" >> "$GITHUB_OUTPUT"
          echo "display=$(date -u +'%b %d, %Y')" >> "$GITHUB_OUTPUT"

      # â”€â”€ 4. Check for existing post (avoid duplicates) â”€â”€
      - name: Check for existing post
        id: existing
        run: |
          SLUG="${{ steps.dates.outputs.today }}-engine-daily-update"
          if [ -f "content/blog/${SLUG}.md" ]; then
            echo "exists=true" >> "$GITHUB_OUTPUT"
          else
            echo "exists=false" >> "$GITHUB_OUTPUT"
          fi

      # â”€â”€ 5. Fetch engine activity from GitHub API â”€â”€
      - name: Fetch engine activity
        if: steps.existing.outputs.exists == 'false'
        id: activity
        env:
          GH_TOKEN: ${{ secrets.GH_PAT || secrets.GITHUB_TOKEN }}
        run: |
          REPO="rivie13/Phoenix-Agentic-Engine"
          SINCE="${{ steps.dates.outputs.since }}"
          # Derive YYYY-MM-DD from the SINCE timestamp so the 24h window is fully covered.
          # Using today's date would miss commits made yesterday after SINCE but before midnight.
          SINCE_DATE=$(echo "${SINCE}" | cut -c1-10)

          # Use commit SEARCH API â€” queries ALL branches, not just default branch.
          # The regular /repos/.../commits endpoint only searches the default branch.
          # Note: the search API does not expose which branch a commit is on, so we omit that field.
          echo "Fetching commits across all branches since ${SINCE_DATE}..."
          COMMITS=$(gh api \
            -H "Accept: application/vnd.github.cloak-preview" \
            "search/commits?q=repo:${REPO}+committer-date:>=${SINCE_DATE}&sort=committer-date&order=desc&per_page=50" \
            --jq '[.items[] | {sha: .sha[0:7], message: .commit.message | split("\n")[0], author: .commit.author.name, url: .html_url}]')

          # Fetch PRs updated in window, then split into merged vs open for clear AI consumption.
          echo "Fetching recently updated PRs (open + merged)..."
          ALL_PRS=$(gh api "repos/${REPO}/pulls?state=all&sort=updated&direction=desc&per_page=30" \
            --jq "[.[] | select(.updated_at >= \"${SINCE}\") | {number, title, state, draft, user: .user.login, url: .html_url, updated_at: .updated_at, merged: (.merged_at != null), head_ref: .head.ref, base_ref: .base.ref, body_excerpt: ((.body // \"\") | gsub(\"\\r|\\n\"; \" \") | gsub(\" +\"; \" \") | .[0:500])}]")
          MERGED_PRS=$(echo "$ALL_PRS" | jq '[.[] | select(.merged == true)]')
          OPEN_PRS=$(echo "$ALL_PRS"   | jq '[.[] | select(.merged == false)]')

          echo "Fetching recently updated issues..."
          ISSUES=$(gh api "repos/${REPO}/issues?state=all&sort=updated&since=${SINCE}&per_page=30" \
            --jq '[.[] | select(.pull_request == null) | {number, title, state, user: .user.login, url: .html_url}]')

          # Count items
          COMMIT_COUNT=$(echo "$COMMITS" | jq 'length')
          MERGED_PR_COUNT=$(echo "$MERGED_PRS" | jq 'length')
          OPEN_PR_COUNT=$(echo "$OPEN_PRS" | jq 'length')
          ISSUE_COUNT=$(echo "$ISSUES" | jq 'length')
          TOTAL=$((COMMIT_COUNT + MERGED_PR_COUNT + OPEN_PR_COUNT + ISSUE_COUNT))

          echo "Found: ${COMMIT_COUNT} commits (all branches), ${MERGED_PR_COUNT} merged PRs, ${OPEN_PR_COUNT} open PRs, ${ISSUE_COUNT} issues"

          if [ "$TOTAL" -eq 0 ]; then
            echo "has_activity=false" >> "$GITHUB_OUTPUT"
            echo "No activity found â€” skipping blog post."
          else
            echo "has_activity=true" >> "$GITHUB_OUTPUT"

            # Write activity data as JSON for the AI prompt
            jq -n \
              --argjson commits "$COMMITS" \
              --argjson merged_prs "$MERGED_PRS" \
              --argjson open_prs "$OPEN_PRS" \
              --argjson issues "$ISSUES" \
              '{commits: $commits, merged_prs: $merged_prs, open_prs: $open_prs, issues: $issues}' > /tmp/activity.json

            echo "Activity data written to /tmp/activity.json"
          fi

      # â”€â”€ 6. Generate blog post via GitHub Models (GPT-5-chat) â”€â”€
      - name: Generate blog post
        if: steps.existing.outputs.exists == 'false' && steps.activity.outputs.has_activity == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          SLUG="${{ steps.dates.outputs.today }}-engine-daily-update"
          SYSTEM_PROMPT=$(cat prompts/daily-blog-system.md)
          ACTIVITY=$(cat /tmp/activity.json)

          USER_MESSAGE="Today's date: ${{ steps.dates.outputs.display }}
          Date (ISO): ${{ steps.dates.outputs.today }}
          Slug: ${SLUG}

          Here is today's engine activity data (JSON):

          ${ACTIVITY}"

          # Call GitHub Models API â€” GPT-5-chat via workflow GITHUB_TOKEN
          # gpt-5-chat: advanced, natural, context-aware â€” better for blog prose than gpt-5-mini.
          # Anthropic/Claude is NOT available on GitHub Models.
          # Model ID confirmed from: https://models.github.ai/catalog/models
          RESPONSE=$(curl -s https://models.github.ai/inference/chat/completions \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer ${GH_TOKEN}" \
            -d "$(jq -n \
              --arg system "$SYSTEM_PROMPT" \
              --arg user "$USER_MESSAGE" \
              '{
                model: "openai/gpt-5-chat",
                messages: [
                  {role: "system", content: $system},
                  {role: "user", content: $user}
                ],
                temperature: 0.7,
                max_tokens: 2000
              }')")

          # Extract the generated content
          CONTENT=$(echo "$RESPONSE" | jq -r '.choices[0].message.content // empty')

          if [ -z "$CONTENT" ]; then
            echo "::error::AI generation failed â€” no content returned"
            if [ "$(echo "$RESPONSE" | jq -r '.error.code // empty')" = "unauthorized" ]; then
              echo "::error::GitHub Models auth failed. Ensure workflow has 'permissions: models: read' and Models access is enabled in repository settings."
            fi
            echo "$RESPONSE" | jq .
            exit 1
          fi

          # Split content into blog post and image prompt
          BLOG_POST_RAW=$(echo "$CONTENT" | sed '/^<!-- IMAGE_PROMPT -->/,$d')
          IMAGE_PROMPT=$(echo "$CONTENT" | awk '/^<!-- IMAGE_PROMPT -->/{flag=1; next} flag{print}' | sed -E '/^[[:space:]]*```[[:alnum:]_-]*[[:space:]]*$/d; /^[[:space:]]*$/d' | head -1)
          HAS_IMAGE_PROMPT_MARKER=false
          if echo "$CONTENT" | grep -q '^<!-- IMAGE_PROMPT -->'; then
            HAS_IMAGE_PROMPT_MARKER=true
          fi

          if [ "$HAS_IMAGE_PROMPT_MARKER" = "true" ] && [ -z "$IMAGE_PROMPT" ]; then
            echo "::error::Generated content contains <!-- IMAGE_PROMPT --> but no valid non-empty image prompt line after it"
            echo "::error::First 20 lines of raw AI output:"
            echo "$CONTENT" | head -n 20
            exit 1
          fi

          # Normalize generated markdown so frontmatter starts at line 1.
          # This prevents accidental wrappers like ```markdown ... ``` from being written into the blog file.
          BLOG_POST=$(echo "$BLOG_POST_RAW" | sed 's/\r$//' | awk '
            BEGIN { started = 0 }
            {
              if (started == 0) {
                if ($0 ~ /^```[[:alnum:]_-]*[[:space:]]*$/) next
                if ($0 ~ /^---$/) { started = 1; print; next }
                next
              }

              if ($0 ~ /^```[[:alnum:]_-]*[[:space:]]*$/) next
              print
            }
          ')

          if ! echo "$BLOG_POST" | head -n 1 | grep -q '^---$'; then
            echo "::error::Generated blog post does not start with YAML frontmatter delimiter ('---')"
            echo "::error::First 5 lines of sanitized output:"
            echo "$BLOG_POST" | head -n 5
            exit 1
          fi

          FRONTMATTER_CLOSE_LINE=$(echo "$BLOG_POST" | awk 'NR > 1 && /^---$/ { print NR; exit }')
          if [ -z "$FRONTMATTER_CLOSE_LINE" ]; then
            echo "::error::Generated blog post frontmatter is missing closing YAML delimiter ('---')"
            echo "::error::First 20 lines of sanitized output:"
            echo "$BLOG_POST" | head -n 20
            exit 1
          fi

          # Write blog post
          mkdir -p content/blog
          printf "%s" "$BLOG_POST" > "content/blog/${SLUG}.md"
          echo "Blog post written to content/blog/${SLUG}.md"

          # Save image prompt for next step
          if [ -n "$IMAGE_PROMPT" ]; then
            echo "$IMAGE_PROMPT" > /tmp/image-prompt.txt
            echo "image_prompt_exists=true" >> "$GITHUB_OUTPUT"
          else
            echo "image_prompt_exists=false" >> "$GITHUB_OUTPUT"
          fi

          echo "slug=${SLUG}" >> "$GITHUB_OUTPUT"

      # â”€â”€ 7. Generate hero image via Pollinations.ai (authenticated gen endpoint) â”€â”€
      - name: Generate hero image
        if: >
          steps.existing.outputs.exists == 'false' &&
          steps.activity.outputs.has_activity == 'true' &&
          vars.BLOG_IMAGE_ENABLED != 'false'
        env:
          POLLINATIONS_API_KEY: ${{ secrets.POLLINATIONS_API_KEY }}
        run: |
          SLUG="${{ steps.dates.outputs.today }}-engine-daily-update"

          if [ -f /tmp/image-prompt.txt ]; then
            PROMPT=$(cat /tmp/image-prompt.txt)
          else
            PROMPT="Abstract digital art, dark background, glowing orange phoenix rising over circuit board patterns, futuristic game engine theme, no text"
          fi

          ENCODED_PROMPT=$(python3 -c "import urllib.parse, sys; print(urllib.parse.quote(sys.stdin.read().strip()))" <<< "$PROMPT")
          POLLINATIONS_GEN_BASE="https://gen.pollinations.ai/image/${ENCODED_PROMPT}?width=1792&height=1024&nologo=true"

          API_KEY=$(echo "${POLLINATIONS_API_KEY}" | sed -E 's/^[[:space:]]+|[[:space:]]+$//g')
          API_KEY=$(echo "${API_KEY}" | sed -E 's/^[Bb]earer[[:space:]]+//')

          if [ -z "${API_KEY}" ]; then
            echo "::warning::POLLINATIONS_API_KEY is missing. Skipping AI hero generation and using Phoenix logo fallback."
            sed -i "s|/images/blog/${SLUG}.png|/images/phoenix-icon.png|" "content/blog/${SLUG}.md"
            echo "Using Phoenix logo as hero image."
            exit 0
          fi

          AUTH_ARGS=(-H "Authorization: Bearer ${API_KEY}")

          KEY_STATUS=$(curl -sS "https://gen.pollinations.ai/account/key" \
            "${AUTH_ARGS[@]}" \
            -H "Accept: application/json" \
            -o /tmp/pollinations-key-status.json \
            -w "%{http_code}") || KEY_STATUS="000"

          if [ "${KEY_STATUS}" != "200" ]; then
            KEY_ERROR=$(jq -r '.error.message // .message // empty' /tmp/pollinations-key-status.json 2>/dev/null || true)
            if [ -z "${KEY_ERROR}" ]; then
              KEY_ERROR="Unable to validate Pollinations API key."
            fi
            echo "::warning::Pollinations key validation failed (HTTP ${KEY_STATUS}). ${KEY_ERROR} Falling back to Phoenix logo."
            sed -i "s|/images/blog/${SLUG}.png|/images/phoenix-icon.png|" "content/blog/${SLUG}.md"
            echo "Using Phoenix logo as hero image."
            exit 0
          fi

          echo "Using authenticated Pollinations image generation."

          fetch_pollinations_image() {
            local base_url="$1"
            local model="$2"
            local source_label="$3"
            local attempt=""
            local http_status=""
            local response_file=""
            local error_message=""

            for attempt in 1 2 3; do
              echo "Attempt ${attempt}/3 via ${source_label} (model: ${model})..."
              response_file=$(mktemp)
              http_status=$(curl -sSL \
                "${base_url}&model=${model}" \
                "${AUTH_ARGS[@]}" \
                -A "PhoenixBlogBot/1.0 (+https://phoenixengine.dev)" \
                --retry 2 \
                --retry-delay 2 \
                --retry-connrefused \
                --max-time 120 \
                -o "${response_file}" \
                -w "%{http_code}") || http_status="000"

              if [ "$http_status" = "200" ] && [ -s "${response_file}" ]; then
                mv "${response_file}" "public/images/blog/${SLUG}.png"
                echo "âœ“ Hero image saved (${source_label}, ${model}) â†’ public/images/blog/${SLUG}.png"
                return 0
              fi

              error_message=$(jq -r '.error.message // .message // empty' "${response_file}" 2>/dev/null || true)
              rm -f "${response_file}" "public/images/blog/${SLUG}.png"

              if [ "$http_status" = "500" ] || [ "$http_status" = "502" ] || [ "$http_status" = "503" ] || [ "$http_status" = "504" ] || [ "$http_status" = "522" ] || [ "$http_status" = "524" ] || [ "$http_status" = "530" ] || [ "$http_status" = "000" ]; then
                echo "Transient error (HTTP ${http_status}) from ${source_label}; retrying..."
                sleep $((attempt * 2))
              else
                if [ -n "${error_message}" ]; then
                  echo "::warning::${source_label} returned HTTP ${http_status} for model ${model}: ${error_message}"
                fi
                break
              fi
            done

            echo "::warning::${source_label} failed for model ${model} (last HTTP ${http_status})"
            return 1
          }

          mkdir -p public/images/blog
          IMAGE_SAVED=false

          # â”€â”€ Tier 1: Authenticated unified endpoint (gen.pollinations.ai) â”€â”€
          if fetch_pollinations_image "${POLLINATIONS_GEN_BASE}" "flux" "gen.pollinations.ai"; then
            IMAGE_SAVED=true
          elif fetch_pollinations_image "${POLLINATIONS_GEN_BASE}" "turbo" "gen.pollinations.ai"; then
            IMAGE_SAVED=true
          fi

          # â”€â”€ Tier 3: Phoenix logo fallback â”€â”€
          if [ "$IMAGE_SAVED" = "false" ]; then
            echo "::warning::All Pollinations attempts failed â€” using Phoenix logo fallback"
            sed -i "s|/images/blog/${SLUG}.png|/images/phoenix-icon.png|" "content/blog/${SLUG}.md"
            echo "Using Phoenix logo as hero image."
          fi

      # â”€â”€ 8. Create PR (Phoenix Website Frontend) â”€â”€
      - name: Create pull request
        if: steps.existing.outputs.exists == 'false' && steps.activity.outputs.has_activity == 'true'
        env:
          GH_TOKEN: ${{ secrets.GH_PAT || secrets.GITHUB_TOKEN }}
        run: |
          SLUG="${{ steps.dates.outputs.today }}-engine-daily-update"
          BRANCH="blog/${SLUG}"
          DATE_DISPLAY="${{ steps.dates.outputs.display }}"

          git config user.name "Phoenix Blog Bot"
          git config user.email "blog-bot@phoenix-engine.dev"

          git checkout -b "${BRANCH}"
          git add content/blog/
          if [ -d "public/images/blog" ] && [ -n "$(ls -A public/images/blog 2>/dev/null)" ]; then
            git add public/images/blog/
          fi
          git commit -m "blog: engine daily update â€” ${DATE_DISPLAY}"
          git push origin "${BRANCH}"

          # Build PR body
          PR_BODY="## ðŸ¤– Automated Daily Blog Post

          **Date**: ${DATE_DISPLAY}
          **Source**: Engine repo activity from the last 24 hours

          ### Preview

          $(head -30 "content/blog/${SLUG}.md" | tail -20)

          ---

          *This PR was automatically generated. Review the post content and merge when ready.*
          *Social posts (Bluesky/LinkedIn) will be triggered after merge if enabled.*"

          gh pr create \
            --title "blog: engine daily update â€” ${DATE_DISPLAY}" \
            --body "$PR_BODY" \
            --base main \
            --head "${BRANCH}" \
            --label "blog,automated"

      # â”€â”€ 9. Cross-post to GitHub Pages (Jekyll) â”€â”€
      # Toggle: set BLOG_CROSSPOST_GITHUB_PAGES to 'true' in repo variables when ready
      - name: Cross-post to GitHub Pages (Jekyll)
        if: >
          steps.existing.outputs.exists == 'false' &&
          steps.activity.outputs.has_activity == 'true' &&
          vars.BLOG_CROSSPOST_GITHUB_PAGES == 'true'
        env:
          GH_TOKEN: ${{ secrets.GH_PAT }}
        run: |
          SLUG="${{ steps.dates.outputs.today }}-engine-daily-update"
          DATE="${{ steps.dates.outputs.today }}"
          DATE_DISPLAY="${{ steps.dates.outputs.display }}"
          JEKYLL_FILENAME="${DATE}-phoenix-engine-update.md"

          # Read the body of the generated post (strip front matter, keep body)
          BODY=$(awk '/^---$/{if(++n==2){found=1; next}} found{print}' "content/blog/${SLUG}.md")

          # Read summary from front matter
          SUMMARY=$(grep '^summary:' "content/blog/${SLUG}.md" | sed 's/^summary: *"//;s/"$//')
          TITLE=$(grep '^title:' "content/blog/${SLUG}.md" | sed 's/^title: *"//;s/"$//')

          # Build Jekyll front matter
          JEKYLL_POST="---
          layout: post
          title: \"${TITLE}\"
          date: ${DATE} 06:00:00 +0000
          categories: [Phoenix, Engine]
          tags: [phoenix-engine, game-dev, godot, ai, daily-update]
          author: Phoenix Blog Bot
          ai_generated: true
          excerpt: \"${SUMMARY}\"
          image: /assets/images/blog-social-image.png
          ---

          > **Automated post** â€” This post was automatically generated by AI from Phoenix Engine activity data. [Read on the Phoenix website](https://phoenixengine.dev/blog/${SLUG}) for the full version with hero image.

          ${BODY}"

          # Push directly to the GitHub Pages repo via API
          # Encode content as base64
          CONTENT_B64=$(echo "$JEKYLL_POST" | base64 -w 0)

          # Check if the file already exists to get its SHA (needed for updates)
          EXISTING=$(gh api "repos/rivie13/rivie13.github.io/contents/_posts/phoenix/${JEKYLL_FILENAME}" \
            --jq '.sha // empty' 2>/dev/null || true)

          if [ -n "$EXISTING" ]; then
            echo "File already exists in GitHub Pages repo â€” skipping"
          else
            # Create the file (no SHA needed for creation).
            PAYLOAD=$(jq -n \
              --arg msg "blog: phoenix engine update â€” ${DATE_DISPLAY}" \
              --arg content "$CONTENT_B64" \
              '{message: $msg, content: $content}')

            gh api "repos/rivie13/rivie13.github.io/contents/_posts/phoenix/${JEKYLL_FILENAME}" \
              --method PUT \
              --input <(echo "$PAYLOAD")

            echo "âœ“ Cross-posted to rivie13.github.io/_posts/phoenix/${JEKYLL_FILENAME}"
          fi
