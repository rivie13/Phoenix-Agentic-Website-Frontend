name: Blog Social â€” Post to Bluesky & LinkedIn

on:
  pull_request:
    types: [closed]
    branches: [main]
  workflow_dispatch:
    inputs:
      slug:
        description: "Blog slug to post manually (example: 2026-02-20-engine-daily-update)"
        required: true
        type: string

# â”€â”€ Permissions â”€â”€
permissions:
  contents: read
  models: read

jobs:
  post-social:
    # Only run for merged, automated daily-blog PRs.
    # This ensures social posting is chained to the Daily Blog workflow output.
    if: >
      github.event_name == 'workflow_dispatch' ||
      (
        github.event.pull_request.merged == true &&
        startsWith(github.event.pull_request.head.ref, 'blog/') &&
        startsWith(github.event.pull_request.title, 'blog: engine daily update') &&
        contains(github.event.pull_request.labels.*.name, 'blog') &&
        contains(github.event.pull_request.labels.*.name, 'automated')
      )
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      # â”€â”€ Extract post metadata â”€â”€
      - name: Extract post info
        id: post
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            SLUG="${{ inputs.slug }}"
          else
            BRANCH_REF="${{ github.event.pull_request.head.ref }}"
            SLUG="${BRANCH_REF#blog/}"
          fi

          SLUG=$(echo "$SLUG" | sed -E 's/^[[:space:]]+|[[:space:]]+$//g')
          echo "Resolved social slug: ${SLUG}"

          # Validate slug format (allow lowercase letters, digits, and hyphens only).
          # Prevent path traversal and malformed URL/file lookups.
          if ! echo "$SLUG" | grep -Eq '^[a-z0-9-]+$'; then
            echo "::warning::Provided slug '${SLUG}' is invalid â€” expected lowercase letters, digits, and hyphens only"
            echo "found=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # For manual runs, ensure the slug exists on origin/main to avoid posting unmerged/stale branch content.
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            git fetch --no-tags --depth=1 origin main
            if ! git cat-file -e "origin/main:content/blog/${SLUG}.md"; then
              echo "::warning::Slug '${SLUG}' does not exist on origin/main â€” skipping social"
              echo "found=false" >> "$GITHUB_OUTPUT"
              exit 0
            fi
          fi

          POST_FILE="content/blog/${SLUG}.md"
          echo "Looking for post file: ${POST_FILE}"

          if [ ! -f "$POST_FILE" ]; then
            echo "::warning::Expected blog post not found at ${POST_FILE} â€” skipping social"
            echo "found=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "found=true" >> "$GITHUB_OUTPUT"

          # Parse front matter (simple grep â€” no deps needed)
          TITLE=$(grep '^title:' "$POST_FILE" | sed 's/^title: *"//;s/"$//')
          SUMMARY=$(grep '^summary:' "$POST_FILE" | sed 's/^summary: *"//;s/"$//')
          SLUG_FROM_FILE=$(grep '^slug:' "$POST_FILE" | sed 's/^slug: *"//;s/"$//')

          if [ -n "$SLUG_FROM_FILE" ]; then
            SLUG="$SLUG_FROM_FILE"
          fi

          if [ -z "$TITLE" ] || [ -z "$SUMMARY" ] || [ -z "$SLUG" ]; then
            echo "::warning::Failed to parse required front matter fields (title/summary/slug) from ${POST_FILE}"
            echo "found=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          echo "title=${TITLE}" >> "$GITHUB_OUTPUT"
          echo "summary=${SUMMARY}" >> "$GITHUB_OUTPUT"
          echo "slug=${SLUG}" >> "$GITHUB_OUTPUT"
          echo "post_file=${POST_FILE}" >> "$GITHUB_OUTPUT"

          # Build the public URL (adjust domain as needed)
          echo "url=https://phoenixengine.dev/blog/${SLUG}" >> "$GITHUB_OUTPUT"

      # â”€â”€ AI social copy generation (GitHub Models) â”€â”€
      - name: Generate AI social copy
        id: ai_social
        if: steps.post.outputs.found == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          TITLE="${{ steps.post.outputs.title }}"
          SUMMARY="${{ steps.post.outputs.summary }}"
          URL="${{ steps.post.outputs.url }}"
          POST_FILE="${{ steps.post.outputs.post_file }}"

          BODY=$(awk '/^---$/{if(++n==2){found=1;next}} found{print}' "$POST_FILE" 2>/dev/null || true)
          BODY_SNIPPET=$(printf "%s" "$BODY" | tr '\r\n' ' ' | sed -E 's/[[:space:]]+/ /g' | cut -c 1-2600)

          USER_MESSAGE=$(jq -n \
            --arg title "$TITLE" \
            --arg summary "$SUMMARY" \
            --arg url "$URL" \
            --arg body "$BODY_SNIPPET" \
            '{
              task: "Generate social posts from a blog post.",
              requirements: {
                bluesky: "<=300 chars total, include URL, include 2-4 relevant hashtags, no markdown/code fences",
                linkedin: "<=1200 chars, professional and approachable tone, include URL and 3-6 hashtags, no markdown/code fences"
              },
              output_format: "Return ONLY valid JSON object: {\"bluesky_text\":\"...\",\"linkedin_text\":\"...\"}",
              input: {
                title: $title,
                summary: $summary,
                url: $url,
                body_excerpt: $body
              }
            }')

          RESPONSE=$(curl -sS https://models.github.ai/inference/chat/completions \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer ${GH_TOKEN}" \
            -d "$(jq -n \
              --arg user "$USER_MESSAGE" \
              '{
                model: "openai/gpt-5-chat",
                messages: [
                  {role: "system", content: "You write concise social posts for engineering updates. Output JSON only."},
                  {role: "user", content: $user}
                ],
                temperature: 0.6,
                max_tokens: 800
              }')") || RESPONSE=""

          CONTENT=$(echo "$RESPONSE" | jq -r '.choices[0].message.content // empty')

          BLUESKY_TEXT=""
          LINKEDIN_TEXT=""

          if [ -n "$CONTENT" ]; then
            PARSED_JSON=$(python3 -c "import re,sys; s=sys.stdin.read(); m=re.search(r'\{[\s\S]*\}', s); print(m.group(0) if m else '')" <<< "$CONTENT")
            if [ -n "$PARSED_JSON" ]; then
              BLUESKY_TEXT=$(echo "$PARSED_JSON" | jq -r '.bluesky_text // empty' 2>/dev/null || true)
              LINKEDIN_TEXT=$(echo "$PARSED_JSON" | jq -r '.linkedin_text // empty' 2>/dev/null || true)
            fi
          fi

          {
            echo "bluesky_text<<EOF"
            echo "$BLUESKY_TEXT"
            echo "EOF"
            echo "linkedin_text<<EOF"
            echo "$LINKEDIN_TEXT"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"

          if [ -z "$BLUESKY_TEXT" ] || [ -z "$LINKEDIN_TEXT" ]; then
            echo "::notice::AI social copy unavailable or unparsable; platform steps will use template fallback text."
          else
            echo "AI social copy generated successfully."
          fi

      # â”€â”€ Bluesky â”€â”€
      - name: Post to Bluesky
        if: >
          steps.post.outputs.found == 'true'
        env:
          BLUESKY_HANDLE: ${{ secrets.BLUESKY_HANDLE }}
          BLUESKY_APP_PASSWORD: ${{ secrets.BLUESKY_APP_PASSWORD }}
          BLUESKY_TOGGLE_RAW: ${{ vars.BLOG_SOCIAL_BLUESKY || vars.blog_social_bluesky }}
          AI_BLUESKY_TEXT: ${{ steps.ai_social.outputs.bluesky_text }}
        run: |
          TITLE="${{ steps.post.outputs.title }}"
          SUMMARY="${{ steps.post.outputs.summary }}"
          URL="${{ steps.post.outputs.url }}"

          BLUESKY_TOGGLE="${BLUESKY_TOGGLE_RAW}"
          BLUESKY_TOGGLE=$(echo "$BLUESKY_TOGGLE" | tr '[:upper:]' '[:lower:]')

          if [ "$BLUESKY_TOGGLE" != "true" ]; then
            echo "::notice::Skipping Bluesky post because toggle is not true. BLUESKY_TOGGLE_RAW='${BLUESKY_TOGGLE_RAW}'"
            exit 0
          fi

          if [ -z "${BLUESKY_HANDLE}" ] || [ -z "${BLUESKY_APP_PASSWORD}" ]; then
            echo "::warning::BLUESKY_HANDLE or BLUESKY_APP_PASSWORD is missing â€” skipping Bluesky post"
            exit 0
          fi

          if [ -n "$AI_BLUESKY_TEXT" ]; then
            TEXT="$AI_BLUESKY_TEXT"
          else
            TAGS="#PhoenixEngine #GameDev #GodotEngine #OpenSource"
            PREFIX="ðŸ¤– ${TITLE}"

            # +6 accounts for separators in final format:
            # PREFIX\n\nSUMMARY\n\nURL\n\nTAGS
            FIXED_LEN=$(( ${#PREFIX} + ${#URL} + ${#TAGS} + 6 ))
            AVAILABLE=$(( 300 - FIXED_LEN ))

            SUMMARY_TRIMMED="$SUMMARY"
            if [ "$AVAILABLE" -lt 0 ]; then
              SUMMARY_TRIMMED=""
            elif [ ${#SUMMARY_TRIMMED} -gt "$AVAILABLE" ]; then
              if [ "$AVAILABLE" -gt 1 ]; then
                SUMMARY_TRIMMED="$(printf '%s' "$SUMMARY_TRIMMED" | cut -c 1-$((AVAILABLE-1)))â€¦"
              else
                SUMMARY_TRIMMED=""
              fi
            fi

            TEXT=$(printf "%s\n\n%s\n\n%s\n\n%s" "$PREFIX" "$SUMMARY_TRIMMED" "$URL" "$TAGS")
          fi

          # Enforce Bluesky hard limit.
          if [ ${#TEXT} -gt 300 ]; then
            TEXT="$(printf '%s' "$TEXT" | cut -c 1-299)â€¦"
          fi

          # Authenticate with Bluesky
          AUTH_STATUS=$(curl -sS -X POST "https://bsky.social/xrpc/com.atproto.server.createSession" \
            -H "Content-Type: application/json" \
            -d "{\"identifier\": \"${BLUESKY_HANDLE}\", \"password\": \"${BLUESKY_APP_PASSWORD}\"}" \
            -o /tmp/bsky-auth.json \
            -w "%{http_code}") || AUTH_STATUS="000"

          AUTH=$(cat /tmp/bsky-auth.json)

          DID=$(echo "$AUTH" | jq -r '.did // empty')
          ACCESS_JWT=$(echo "$AUTH" | jq -r '.accessJwt // empty')

          if [ "$AUTH_STATUS" != "200" ] || [ -z "$DID" ] || [ -z "$ACCESS_JWT" ]; then
            echo "::warning::Bluesky authentication failed (HTTP ${AUTH_STATUS})"
            echo "$AUTH" | jq .
            exit 0  # Don't fail the workflow over social
          fi

          # Create post
          NOW=$(date -u +"%Y-%m-%dT%H:%M:%S.000Z")

          POST_STATUS=$(curl -sS -X POST "https://bsky.social/xrpc/com.atproto.repo.createRecord" \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer ${ACCESS_JWT}" \
            -d "$(jq -n \
              --arg did "$DID" \
              --arg text "$TEXT" \
              --arg now "$NOW" \
              '{
                repo: $did,
                collection: "app.bsky.feed.post",
                record: {
                  "$type": "app.bsky.feed.post",
                  text: $text,
                  createdAt: $now
                }
              }')" \
            -o /tmp/bsky-post.json \
            -w "%{http_code}") || POST_STATUS="000"

          RESPONSE=$(cat /tmp/bsky-post.json)

          if [ "$POST_STATUS" != "200" ]; then
            echo "::warning::Bluesky post failed (HTTP ${POST_STATUS})"
            echo "$RESPONSE" | jq .
            exit 0
          fi

          echo "Bluesky post created:"
          echo "$RESPONSE" | jq -r '.uri // "unknown"'

      # â”€â”€ LinkedIn â”€â”€
      - name: Post to LinkedIn
        if: >
          steps.post.outputs.found == 'true'
        env:
          LINKEDIN_ACCESS_TOKEN: ${{ secrets.LINKEDIN_ACCESS_TOKEN }}
          LINKEDIN_PERSON_URN: ${{ secrets.LINKEDIN_PERSON_URN }}
          LINKEDIN_TOGGLE_RAW: ${{ vars.BLOG_SOCIAL_LINKEDIN || vars.blog_social_linkedin }}
          AI_LINKEDIN_TEXT: ${{ steps.ai_social.outputs.linkedin_text }}
        run: |
          TITLE="${{ steps.post.outputs.title }}"
          SUMMARY="${{ steps.post.outputs.summary }}"
          URL="${{ steps.post.outputs.url }}"

          LINKEDIN_TOGGLE="${LINKEDIN_TOGGLE_RAW}"
          LINKEDIN_TOGGLE=$(echo "$LINKEDIN_TOGGLE" | tr '[:upper:]' '[:lower:]')

          if [ "$LINKEDIN_TOGGLE" != "true" ]; then
            echo "::notice::Skipping LinkedIn post because toggle is not true. LINKEDIN_TOGGLE_RAW='${LINKEDIN_TOGGLE_RAW}'"
            exit 0
          fi

          if [ -n "$AI_LINKEDIN_TEXT" ]; then
            TEXT="$AI_LINKEDIN_TEXT"
          else
            TEXT="ðŸ¤– ${TITLE}

            ${SUMMARY}

            Read more: ${URL}

            #PhoenixEngine #GameDev #GodotEngine #OpenSource"
          fi

          RESPONSE=$(curl -s -X POST "https://api.linkedin.com/v2/ugcPosts" \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer ${LINKEDIN_ACCESS_TOKEN}" \
            -H "X-Restli-Protocol-Version: 2.0.0" \
            -d "$(jq -n \
              --arg urn "$LINKEDIN_PERSON_URN" \
              --arg text "$TEXT" \
              --arg url "$URL" \
              --arg title "$TITLE" \
              '{
                author: $urn,
                lifecycleState: "PUBLISHED",
                specificContent: {
                  "com.linkedin.ugc.ShareContent": {
                    shareCommentary: {text: $text},
                    shareMediaCategory: "ARTICLE",
                    media: [{
                      status: "READY",
                      originalUrl: $url,
                      title: {text: $title}
                    }]
                  }
                },
                visibility: {
                  "com.linkedin.ugc.MemberNetworkVisibility": "PUBLIC"
                }
              }')")

          echo "LinkedIn post created:"
          echo "$RESPONSE" | jq -r '.id // "unknown"'
